"use client";
import React, { useState, useEffect } from "react";

const ReactDocsExamples: React.FC = () => {
  const [firstName, setFirstName] = useState<string>("");
  const [lastName, setLastName] = useState<string>("");
  const [fullName, setFullName] = useState<string>("");

  const handleFirstNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFirstName(e.target.value);
  };

  const handleLastNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setLastName(e.target.value);
  };

  //this fullname variable doesn't make the whole page re-render like a useEffect might.
  const fullNameConst = firstName + " " + lastName;

  //using a UseEffect for this purpose makes the whole page re-render.
  //thus rebuilding the whole DOM
  //useMemo -> caching expensive calculations. basically don't re-run the filter unless these have changed.
  
//   useEffect(() => {
//     setFullName(firstName + " " + lastName);
//   }, [firstName, lastName]);

  //memoization is a optimization technique used primairly to speed up computer programs by storing the results of expensive function calls to pure functions and returing the cached result when the same inputs occur again. Its a type of caching.

  return (
    <div>
      <input
        type="text"
        value={firstName}
        onChange={handleFirstNameChange}
        placeholder="first name"
        className="p-2 m-2 text-black"
      />
      <input
        type="text"
        value={lastName}
        onChange={handleLastNameChange}
        placeholder="last name"
        className="p-2 m-2 text-black"
      />

      <p>generated by useEffect this is a full name: {fullName}</p>
      <p>
        generated by const variable this is also a full name: {fullNameConst}
      </p>
    </div>
  );
};

export default ReactDocsExamples;
